'''
 УКрошаестьмассивизnэлементов,пронумерованных слева направо от 1 до n. Каждыйэлемент
 имеет значение ai и стоимость удаления ci. Крош играет на этом массиве в следующую игру. За
 один ход он берет пару соседних элементов и удаляет из них наименьший по значению, при этом
 платит стоимость удаления наименьшего по значению элемента за эту операцию. То есть, удаляем
 наименьший элемент и платим его стоимость удаления. У Кроша есть сумма s, которую можно
 потратить на удаление элементов. Помогите ему найти наибольшее значение, которое может принять
 минимум этого массива после нуля или более операций. Обратите внимание, в массиве должен
 остаться хотя бы один элемент, так как для него не существует пары. При удалении элементы
 смещаются, то есть не остаётся пропусков.
 Формат входных данных
 В первой строке вам даны два числа 1 n 105 и 0 s 1018. В следующей строке заданы
 значения элементов 0 ai 109. В следующей строке даны стоимости удаления 0 ci 109.
 Система оценки
 • Подзадача 1 (50 баллов) n 100
 • Подзадача 2 (50 баллов) без дополнительных ограничений, необходимые подазадачи– 1
 Формат выходных данных
 Выведите одно число- наибольшее значение, которое может принять минимум в массиве.
'''

import sys


def binary_search(arr, x): # Поиск первого элемента >= x в отсортированном массиве
    left, right = 0, len(arr)  # левая и правая границы
    while left < right:
        mid = (left + right) // 2  # середина отрезка
        if arr[mid] < x:
            left = mid + 1 # Если текущий элемент меньше x, ищем в правой
        else:
            right = mid
    return left  # Индекс первого элемента >= x

def main():
    data = sys.stdin.read().strip().split() # Чтение данных
    if not data:
        return
    it = iter(data)  # Создаем итератор

    n = int(next(it))
    s = int(next(it))

    # Массив значений a_i
    a = [int(next(it)) for _ in range(n)]
    # Массив стоимостей удаления c_i
    c = [int(next(it)) for _ in range(n)]

    # Создаем пары (значение, стоимость)
    pairs = [(a[i], c[i]) for i in range(n)]
    # Сортируем пары по значению a_i по возрастанию
    pairs.sort(key=lambda x: x[0])
    # Извлекаем отсортированные значения a_i
    sorted_a = [p[0] for p in pairs]

    # Массив префиксных сумм
    pref_cost = [0] * (n + 1)
    for i in range(n):
        pref_cost[i + 1] = pref_cost[i] + pairs[i][1]

    # Минимум X
    def can_achieve_min(X):
        # Индекс первого элемента >= X
        idx = binary_search(sorted_a, X)
        if idx == n:
            return False

        # Сумма стоимостей всех элементов < X
        total_cost = pref_cost[idx]
        return total_cost <= s

    # Максимальный возможный минимум
    left, right = 0, 10 ** 9 + 1
    while left < right:
        mid = (left + right + 1) // 2  # Берем среднее с округлением вверх
        if can_achieve_min(mid):
            # Если можно достичь минимум mid, пробуем увеличить
            left = mid
        else:
            #уменьшаем верхнюю границу
            right = mid - 1

    print(left)


if __name__ == "__main__":
    main()